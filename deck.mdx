import { Appear,Code, Head, Image, Notes } from 'mdx-deck'
import TallImage from './src/tall-image';
import AboutMe from './src/about-me';

export { default as theme } from './src/theme'

<Head>
  <title>Building a Code Split React App</title>
</Head>

# Building a Code Split React App
---
<AboutMe />
---
# Let’s talk about single page apps
---
<TallImage src='assets/timber.gif' />
---
<TallImage src='assets/create-react-app.png' />
---
## create-react-app
<ul>
  <Appear>
  <li>yarn add redux</li>
  <li>yarn add typescript</li>
  <li>yarn add lodash</li>
  <li>Write a lot of javascript</li>
  <li>Write a lot of css</li>
	</Appear>
</ul>
---
<TallImage src='assets/heaviest-objects.jpg' />
---
# 10 MB of JavaScript
---
<table>
	<thead>
		<th>Country</th>
		<th>Average Speed</th>
		<th>Time</th>
	</thead>
	<tbody>
		<tr>
			<td>South Korea</td>
			<td>28.6 Mbps </td>
			<td>2.80s</td></tr>
		<tr>
			<td>Norway</td>
			<td>23.5 Mbps </td>
			<td>3.40s</td></tr>
		<tr>
			<td>Sweden</td>
			<td>22.5 Mbps </td>
			<td>3.56s</td></tr>
		<tr>
			<td>Hong Kong</td>
			<td>21.9 Mbps </td>
			<td>3.65s</td></tr>
		<tr>
			<td> Switzerland</td>
			<td>21.7 Mbps </td>
			<td>3.69s</td></tr>
		<tr>
			<td>Finland</td>
			<td>20.5 Mbps </td>
			<td>3.90s</td></tr>
		<tr>
			<td>Singapore</td>
			<td>20.3 Mbps </td>
			<td>3.94s</td></tr>
		<tr>
			<td>Japan</td>
			<td>20.2 Mbps </td>
			<td>3.96s</td></tr>
		<tr>
			<td>Denmark</td>
			<td>20.1 Mbps </td>
			<td>3.98s</td></tr>
		<tr>
			<td>United States</td>
			<td>18.7 Mbps </td>
			<td>4.28s</td></tr>
	</tbody>
</table>
---
# How do we deal with this
---
# Code split
---
# ONE GIANT BUNDLE GIF
---
# Many SMALL BUNDLES GIF
---
# This is not new
---
- Routes - php, rails, django
- Vendor (jQuery, Underscore, Backbone) - Cached on every page
- Page bundle (App Code) - Changes more often
---
- We go from synchronous import to async
  - import → import.then
---
```
	import * as widget from "./widget";

	function renderWidget() {
		const container = document.getElementById("widget");
		widget.render(container);
	}

	renderWidget();
```
---
```
	async function renderWidget() {
		const container = document.getElementById("widget");
		const widget = await import("./widget");
		widget.render(container);
	}

	renderWidget();
```
---
# React gives us some pretty great wrappers around this
---
# Lazy/Suspense
---
```
const OtherComponent = React.lazy(() => import('./OtherComponent'));

function MyComponent() {
  return (
    <div>
      <Suspense fallback={<div>Loading...</div>}>
        <OtherComponent />
      </Suspense>
    </div>
  );
}
```
---
# These are typesafe!
<Notes>
	More on typer later
</Notes>
---
# We're done here GIF
---
Data Layer
---
# Good tooling doesn’t really exist here
---
# Let's talk about Redux
---
# Flux diagram here
---
# Vocab
<Appear>
	<ul>
		<li>Namespace/Slice</li>
		<li>Reducer</li>
		<li>Action</li>
		<li>Selector</li>
		<li>State</li>
		<li>Store</li>
	</ul>
</Appear>
---
# Slytherin.dev
<Notes>
	bunch of users, show off types of data we can query
</Notes>
---
# Naive Redux Store
  - Picture of All the namespaces
  - Picture of All the reducers
  - Picture of All the actions
  - Picture of All the selectors
---
# Typed Naive Redux
---
Reducer function signature
<Notes>
each reducer knows every possible action it can receive
</Notes>
---
Selector function signature
<Notes>
  our selectors always return the right thing
</Notes>
---
dispatch bad action screenshot
---
check bad payload screenshot
---
# Naive Redux Store
  - Picture of All the namespaces
  - Picture of All the reducers
  - Picture of All the actions
  - Picture of All the selectors
---
Back to codesplitting
---
# Actions are *easy* to codesplit
<Notes>They're just functions</Notes>
---
# Selectors are *easy* to codesplit
<Notes>They're also just functions</Notes>
---
# Reducers are *hard* to codesplit
Why?
---
```
const store = createStore(
	reducer,
	enhancer
)
```
---
# We need the root reducer at store creation
---
# The root reducer is composed of every possible reducer we want to include
---
# Dropbox Scale
---
# We built this for Dropbox
<ul>
	<Appear>
		<li>200+ engineers working on the same codebase</li>
		<li>25 Namespaces</li>
		<li>Any given page might need a permutation of 5-10</li>
		<li>SF, NY, TLV, SEA</li>
	</Appear>
</ul>
---
# We can’t guarantee that single a reducer is never expensive.
<Notes>
  - Theres nothing stopping a single team from including all of lodash as a dependency in their reducer.
  - Even if we could, there could be a good reason for it to be expensive
</Notes>
---
# This has to run on every page.
---
# We’ve gotta figure out how to codesplit the reducer
---
Slytherin.dev homepage, mouse over tweets
---
tweets page
- what reducers are registered
- what code is on the client
	- tweetsPage
	- tweetsReducer
	- tweetsAction
---
navigate Back
---
navigate to gifs
---
same thing as above + gif stuff
---
# How do we build this?
---
# What do we want to optimize for?
---
# Soundness
---
# Works perfectly, or completely breaks, nothing in between
---
# Failure Modes
<ul>
	<Appear>
	<li>Silent errors</li>
	<li>Works on my machine</li>
	<li>Race conditions</li>
	</Appear>
</ul>
---
# How do we enforce Soundness
---
# Compile Time - Typechecking
---
# Runtime - when the code is executing in the browser
---
# What are our requirements for this tooling
---
# Good developer experience
<Notes>
	Abstractions around code splitting, engineers shouldn’t have to think about code splitting when they’re building features.
</Notes>
---
# We should have strong runtime assertions to check data is there, so we can fail fast.
<Notes>
	- Feature, not a bug, that any given slice of the state may or may not be available when a selector is called.
	- We need to isolate where failure modes can happen as a result of codesplitting
	- We do not want developers to be able to call a selector if a namespace is not registered.
</Notes>

  -
# Requirements
<ul>
<Appear>
  <li>Abstractions around code splitting, consumers shouldn’t *know* we’re code splitting</li>
  <li>Isolate the integration points (where it isnt typesafe)</li>
  <li>If it’s not typesafe at compile time we want strong typesafety at runtime</li>
</Appear>
</ul>
---
- Strong central typing layer
- getStoreWithReducers
  - Singleton pattern
  - Still not a very good abstraction
- CodeSplitProvider
  - Now we really abstract it
- Selector layer enforces types
  - Show off the sibling production bug
- Action enforcer middleware
- Walkthrough of an app that handles this well
  - Shows how and when code is loaded
  - Shows how and when types are guaranteed
---
Graph were it only knows about what it needs
---
We know about everything all the time

# References
-

https://en.wikipedia.org/wiki/List_of_countries_by_Internet_connection_speeds
https://mariusschulz.com/blog/typescript-2-4-dynamic-import-expressions
